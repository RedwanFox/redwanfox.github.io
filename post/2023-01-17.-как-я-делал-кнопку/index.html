<!DOCTYPE html>
<html lang="ru-ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Как я делал кнопку | Power Of The Sword Derivative</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
    </ul>
    <hr/>
    </nav>


<div class="article-meta">
<h1><span class="title">Как я делал кнопку</span></h1>

<h2 class="date">2023/01/14</h2>
<p class="terms">
  
  
  
  
  Tags: <a href="/tags/%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">разработка</a> <a href="/tags/godot">godot</a> 
  
  
</p>
</div>


<main>
<p>В октябре за пару недель с нуля на больной гиперактивности от вынужденного переезда накидал в godot 4.0 относительно нормальный first person shooter контроллер персонажа. Делал все на gdscript, чтобы не заморачиваться. После того как получил бегающего, прыгающего и передвигающегося присев (в том числе сквозь туннели) персонажа отложил все в сторону до лучших времен, наличия личных сил и починки багов в движке, которые я чинить сам не хотел.</p>
<p>Новогодние праздники стали предположительным сочетанием этих трех факторов, и я решил вернуться к демке и сделать что-то простое по фану. Этим простым я посчитал задачу &ldquo;сделать кнопку&rdquo; (и максимально интегрировать все происходящее в редактор). О, как я ошибался.</p>
<h2 id="сделать-кнопку">Сделать кнопку</h2>
<p>Что я понимаю под &ldquo;сделать кнопку&rdquo;?</p>
<p>&ldquo;Сделать кнопку&rdquo; равно &ldquo;запилить простенькую систему интерактивных объектов, с которыми персонаж может взаимодействовать на уровне&rdquo;. По факту такое взаимодействие сводится к следующим пунктам:</p>
<ol>
<li>У персонажа есть некая зона, которая при соприкосновением или пересечениями с другими зонами, дает персонажу информацию об этом и на нажатие действия &ldquo;использовать&rdquo; на клавиатуре активируется некое интерактивное действие. Эта зона активно следит за пересечением.</li>
<li>На объект карты ставится вторая зона, которая никак не взаимодействует с другими, но дает знать о своем существовании.</li>
<li>Само интерактивное действие является независимым типом данных и его можно выбрать в property view в редакторе.</li>
<li>И при входе/выходе из зоны, в которой можно активировать интерактивное действие, появляется или прячется подсказка в UI.</li>
</ol>
<p>Первые 3 пункта прошли <em>почти</em> без приключений. Godot не умеет экспортировать в редактор все типы данных, а только некоторые, поэтому пришлось воспользоваться трюком с разделением моих обработчиков действий, на тип-конфиг, который виден из редактора, сериализуется и имеет всего один метод &ldquo;создать настоящий обработчик&rdquo;.</p>
<p>В какой-то момент выяснилось, что дочерние объекты классов, исполняющихся в редакторе, которые участвуют в 3д сцене, не умеют показывать свой дебажный визуал, если созданы из кода, а не из редактора. Зарепортил <a href="https://github.com/godotengine/godot/issues/71408">баг</a> сильно позже, когда писал этот пост. В ходе обсуждения выяснилось, что это не в движке проблема, а я набажил. У меня стрелял ассерт и это делало объект недоинициализованным в редакторе. Эх.</p>
<p>Интерфейc же принес целый ворох проблем.</p>
<h2 id="интерфейс-пользователя">Интерфейс пользователя</h2>
<p>Ну тут виноват я сам, вместо того, чтобы на говнокодить я решил сделать просто, но по-нормальному.</p>
<ol>
<li>Есть один или несколько лейаутов с пустыми контейнерами под пользовательские виджеты.</li>
<li>При старте игры виджеты по конфигу заполняют эти контейнеры, а еще в зависимости от состояния хозяина интерфейса (персонажа игрока в игре) виджеты могут включаться и выключаться.</li>
<li>Лейаут знает только о местоположении виджетов и их id, конфиг знает id</li>
<li>Всем этим рулит скрипт, который подписан на овнера интерфейса и при изменениях включает-выключает виджеты. Скрипт висит как подсистема-синглтон.</li>
</ol>
<p>Тут тоже начались проблемы с отображением всех контуров контейнеров в редакторе, но я просто забил.</p>
<p>Дальше я захотел, чтобы лейауты пользователь мог добавлять через конфиг проекта в редакторе и вот тут все начало взрываться. Для конфига надо завести свои типы данных, и потом зарегистрировать их переменные через синглтон. Региструются нормально, пишутся и сохраняются нормально, при перезагрузке редактора движок сначала считает, что файл проекта неправильный, <em>как-то</em> его пытается его исправить, после 100% крашит.</p>
<p>Провозился полдня, похоже движок сначала грузит синглтон и пытается загрузить настройки, а только потом хочет дочитать все остальные скрипты в проекте и зарегистрировать все пользовательские типы данных. Не найдя типы данных, редактор говорит ПНХ и крашится. В результате зарепортил <a href="https://github.com/godotengine/godot/issues/70817">баг</a> и забил. Леайуты остались прибитыми в коде до лучших времен.</p>
<p>После этого интерфейс худо-бедно заработал, я отделил дебажные виджеты от персонажа - они начали снаружи каждый кадр его опрашивать - осталось заставить его включать-выключать виджеты. Для этого надо знать об игроке и уметь подписаться на его состояние.</p>
<p>Обе эти задачи породили еще больше проблем.</p>
<h2 id="инфраструктурные-классы">Инфраструктурные классы</h2>
<p>Если говорить упрощенно, во время работы godot обходит дерево объектов каждый кадр, и во время инициализации, чем ближе объект к корню дерева, тем раньше отрабатывает его инициализация. И все это крутится внутри объекта MainLoop приложения. Игрок такой же объект в дереве и нет специальной логики для его размещения на уровне, а также логики, чтобы как-то его доставать в любой момент.</p>
<p>Движок предоставляет 2 варианта как решать проблему доступа к общей логике:</p>
<ol>
<li>Ноды-синглтоны, к которым можно обращаться по имени. Подходит больше для подсистем, типа интерфейса пользователя выше.</li>
<li>Свой MainLoop. Доступен из любой ноды и содержит в себе всю низкоуровневую логику.</li>
</ol>
<p>Второй подход выглядел более органичным, и я пошел по нему. Примерная схема получилась похожей на то, что происходит в unreal engine на минималках:</p>
<ol>
<li>Сцена, являющаяся игровым уровнем, должна в корне иметь ноду типа GameLevel. Эта нода на старте загрузки инициализирует ноду типа GameMode, которая конфигурируется из редактора и по окончанию загрузки кидает событие level_loaded.</li>
<li>GameMode содержит в себе логику игрового режима и спавна объекта конкретного типа персонажа игрока. А затем по окончанию загрузки спавнит игрока на уровень.</li>
<li>Есть свой кастомый MainLoop - GameLoop - отличающийся от стандартного только тем, что через него можно получить GameMode и игрока.</li>
</ol>
<p>Минусы: надо об этой инфраструктуре знать. Плюсы: устаканивает доступ к основным игровым объектам, разрезает прямые зависимости между игровым уровнем, игровым режимом и персонажем игрока.</p>
<p>В целом получилось сделать ровно как хотел, но, конечно же, кастомные MainLoop оказались <a href="https://github.com/godotengine/godot/issues/70764">сломаны</a>. Баг был уже заведен, подписался, жду мерджа, пока закостылил вокруг немного.</p>
<h2 id="система-тегов">Система тегов</h2>
<p>Стейт объектов, связанный с состоянием (а не чисельными параметрами), можно описывать несколькими способами:</p>
<ol>
<li>Набор захардкоженных флажков в типе. Этот способ хорош для tightly coupled систем, но не подходит для того, что мне хочется.</li>
<li>Система тегов, которые можно вешать на любой объект, на изменение состояния которых можно подписаться. Поэтому решил написать ее.</li>
</ol>
<p>В godot есть похожая система групп нод, но она не подходят, потому что они концептуально для другого (отфильтровать объекты в дереве и вызвать у всех какой-нибудь метод), а еще на изменения групп нельзя подписаться.</p>
<p>Схема получившейся системы вот такая:</p>
<ol>
<li>Теги - это енум.</li>
<li>Теги содержатся в TagContainer, по сути hashset с тегами, и удобными методами. TagContainer можно вешать на любую ноду.</li>
<li>Есть TagRequirements, которые можно задавать через редактор. Внутри 2 коллекции тегов required и ignored. Можно проверять коллекцию тегов на соответствие.</li>
</ol>
<p>В gdscript нету hashset-ов. Они есть в движке, но наружу в скрипты не вытащены. Посмотрел, что чтобы запатчить, надо просидеть пару дней за написанием автотестов. Забил, сделал костыль над Dictionary. Но это ничего.</p>
<p>&ldquo;Чего&rdquo; это godot-овская сериализация енумов. Она доставила мне особое удовольствие. Следите за руками.</p>
<p>Есть енум:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>enum ETags {
</span></span><span style="display:flex;"><span>   TagA, <span style="color:#75715e"># неявно выставлено значение в 0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Он используется в сериализуемом игровом ресурсе в поле <code>Tags</code>, которое можно редактировать из редактора. Когда ресурс сохраняется в него записывается в файлик, как</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Tags <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
</span></span></code></pre></div><p><em>Циферкой</em>. Коллекция тегов часто меняется. Добавим еще один тег.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>enum ETags {
</span></span><span style="display:flex;"><span>  OtherTag, <span style="color:#75715e"># теперь этот стал 0</span>
</span></span><span style="display:flex;"><span>  TagA, <span style="color:#75715e"># а этот стал 1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>В енуме поменялось значение де-факто поменялось, как и должно и в видимых полях редактора текстовое значение не поменялось, как и должно. А вот сериализованные объекты все пошли к чертям, потому что значение енума в них также не поменялось.</p>
<p>В анриле эта подперто тем, что сериализуются строковые значения енумов и ломается в результате только кейс с переименованием. Да и то, это ловится быстро и решительно на этапе валидации объекта в память при десериализации.</p>
<p>Результат как всегда: зарепортил <a href="https://github.com/godotengine/godot/issues/70972">баг</a>. Но это уже какой-то край.</p>
<h2 id="итого">Итого</h2>
<p>После всего этого я доделал UI и получил демку FPS с минимальным готовым набором элементов, чтобы делать уже непосредственно геймплейные вещи.</p>
<p>За неделю развлечений я словил какое-то неимоверное количество багла на ровном месте. Были мыслишки переключиться на unreal, пилить на нем, но решил не переключаться, чтобы опробовать самому делать все игровые запчасти минималистичными, понятными для восприятия и легко поддерживаемыми.</p>
<p>Следующим, за что я возьмусь, будет попытка прикрутить к текущей демке возможность анимированных атак ближнего боя с игровыми объектами, которые на эти атаки реагируют. Да будет демка ИЗБИВАТЬ КРАПИВУ ПАЛКОЙ.</p>

</main>

  <footer>
  
  
  <hr/>
  © <a href="https://github.com/RedwanFox">Github</a> | <a href="https://t.me/power_of_the_sword_derivative">Telegram</a>
  
  </footer>
  </body>
</html>

